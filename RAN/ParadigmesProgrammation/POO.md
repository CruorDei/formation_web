# Qu'est-ce que la programmation orient√©e objet ?
[H2Prog : Programmation Orient√©e Objet : vid√©o d'introduction √† la POO](<https://youtu.be/bgmMg2ZdpVU>)

La programmation orient√©e objet (POO) est un mod√®le de programmation informatique qui organise la conception de logiciels autour de donn√©es, ou d'objets, plut√¥t que de fonctions et de logique. Un objet peut √™tre d√©fini comme un champ de donn√©es dot√© d'attributs et d'un comportement uniques.

La POO se concentre sur les objets que les d√©veloppeurs veulent manipuler plut√¥t que sur la logique requise pour les manipuler. Cette approche de la programmation est bien adapt√©e aux programmes volumineux, complexes et activement mis √† jour ou maintenus. Cela comprend des programmes de fabrication et de conception, ainsi que des applications mobiles ; par exemple, la POO peut √™tre utilis√©e pour fabriquer un logiciel de simulation de syst√®me.

L'organisation d'un programme orient√© objet rend √©galement la m√©thode b√©n√©fique au d√©veloppement collaboratif, o√π les projets sont divis√©s en groupes. Les avantages suppl√©mentaires de la POO incluent la r√©utilisation du code, l'√©volutivit√© et l'efficacit√©.

La premi√®re √©tape de la POO consiste √† collecter tous les objets qu'un programmeur souhaite manipuler et √† identifier leurs relations les uns avec les autres - un exercice connu sous le nom de mod√©lisation des donn√©es.

Les exemples d'objet peuvent aller d'entit√©s physiques, telles qu'un √™tre humain d√©crit par des propri√©t√©s telles que le nom et l'adresse, √† de petits programmes informatiques, tels que des widgets .

Une fois qu'un objet est connu, il est √©tiquet√© avec une classe d'objets qui d√©finit le type de donn√©es qu'il contient et toutes les s√©quences logiques qui peuvent le manipuler. Chaque s√©quence logique distincte est connue sous le nom de m√©thode. Les objets peuvent communiquer avec des interfaces bien d√©finies appel√©es messages.

## Quelle est la structure de la programmation orient√©e objet ?

La structure, ou les blocs de construction, de la programmation orient√©e objet comprend les √©l√©ments suivants :

- Les classes sont des types de donn√©es d√©finis par l'utilisateur qui servent de mod√®le pour des objets, des attributs et des m√©thodes individuels.
- Les objets sont des instances d'une classe cr√©√©e avec des donn√©es sp√©cifiquement d√©finies. Les objets peuvent correspondre √† des objets du monde r√©el ou √† une entit√© abstraite. Lorsque la classe est d√©finie initialement, la description est le seul objet d√©fini.
- Les m√©thodes sont des fonctions d√©finies √† l'int√©rieur d'une classe qui d√©crivent les comportements d'un objet. Chaque m√©thode contenue dans les d√©finitions de classe commence par une r√©f√©rence √† un objet d'instance. De plus, les sous-routines contenues dans un objet sont appel√©es m√©thodes d'instance. Les programmeurs utilisent des m√©thodes de r√©utilisation ou de maintien des fonctionnalit√©s encapsul√©es dans un objet √† la fois.
- Les attributs sont d√©finis dans le mod√®le de classe et repr√©sentent l'√©tat d'un objet. Les objets auront des donn√©es stock√©es dans le champ des attributs. Les attributs de classe appartiennent √† la classe elle-m√™me.

![](https://cdn.ttgtmedia.com/rms/onlineimages/whatis-object_oriented_programming.png)

## Quels sont les grands principes de la POO ?

La programmation orient√©e objet est bas√©e sur les principes suivants :

- Encapsulation . Ce principe stipule que toutes les informations importantes sont contenues dans un objet et que seules les informations s√©lectionn√©es sont expos√©es. L'impl√©mentation et l'√©tat de chaque objet sont d√©tenus en priv√© dans une classe d√©finie. Les autres objets n'ont pas acc√®s √† cette classe ni le droit d'apporter des modifications. Ils ne peuvent appeler qu'une liste de fonctions ou de m√©thodes publiques. Cette caract√©ristique de masquage des donn√©es offre une plus grande s√©curit√© du programme et √©vite la corruption involontaire des donn√©es.
- L'abstraction . Les objets ne r√©v√®lent que les m√©canismes internes pertinents pour l'utilisation d'autres objets, cachant tout code d'impl√©mentation inutile. La classe d√©riv√©e peut voir ses fonctionnalit√©s √©tendues. Ce concept peut aider les d√©veloppeurs √† apporter plus facilement des modifications ou des ajouts suppl√©mentaires au fil du temps.
- H√©ritage . Les classes peuvent r√©utiliser le code d'autres classes. Les relations et les sous-classes entre les objets peuvent √™tre attribu√©es, permettant aux d√©veloppeurs de r√©utiliser la logique commune tout en conservant une hi√©rarchie unique. Cette propri√©t√© de la POO oblige √† une analyse plus approfondie des donn√©es, r√©duit le temps de d√©veloppement et assure un niveau de pr√©cision plus √©lev√©.
- Polymorphisme . Les objets sont con√ßus pour partager des comportements et ils peuvent prendre plusieurs formes. Le programme d√©terminera quelle signification ou utilisation est n√©cessaire pour chaque ex√©cution de cet objet √† partir d'une classe parente, r√©duisant ainsi le besoin de dupliquer le code. Une classe enfant est alors cr√©√©e, ce qui √©tend les fonctionnalit√©s de la classe parent. Le polymorphisme permet √† diff√©rents types d'objets de passer par la m√™me interface.

## Quels sont les exemples de langages de programmation orient√©s objet ?

Alors que Simula est consid√©r√© comme le premier langage de programmation orient√© objet, de nombreux autres langages de programmation sont aujourd'hui utilis√©s avec la POO. Mais certains langages de programmation s'associent mieux √† la POO que d'autres. Par exemple, les langages de programmation consid√©r√©s comme des langages POO purs traitent tout comme des objets. D'autres langages de programmation sont con√ßus principalement pour la POO, mais avec certains processus proc√©duraux inclus.

Par exemple, les langages POO purs populaires incluent :
    Rubis
    Scala
    JADE
    Emerald

Les langages de programmation con√ßus principalement pour la POO incluent :
    Java
    Python
    C++

Les autres langages de programmation associ√©s √† la POO incluent :
    Visual Basic .NET
    PHP
    Javascript

## Quels sont les avantages de la POO ?

Les avantages de la POO incluent :

- Modularit√©. L'encapsulation permet aux objets d'√™tre autonomes, ce qui facilite le d√©pannage et le d√©veloppement collaboratif.
- R√©utilisabilit√©. Le code peut √™tre r√©utilis√© par h√©ritage, ce qui signifie qu'une √©quipe n'a pas √† √©crire le m√™me code plusieurs fois.
- Productivit√©. Les programmeurs peuvent construire de nouveaux programmes plus rapidement gr√¢ce √† l'utilisation de plusieurs biblioth√®ques et d'un code r√©utilisable.
- Facilement √©volutif et √©volutif. Les programmeurs peuvent impl√©menter les fonctionnalit√©s du syst√®me de mani√®re ind√©pendante.
- Descriptif des interfaces . Les descriptions des syst√®mes externes sont simples, gr√¢ce aux techniques de transmission de messages utilis√©es pour la communication des objets.
- S√©curit√©. Gr√¢ce √† l'encapsulation et √† l'abstraction, le code complexe est masqu√©, la maintenance logicielle est facilit√©e et les protocoles Internet sont prot√©g√©s.
- Souplesse. Le polymorphisme permet √† une seule fonction de s'adapter √† la classe dans laquelle elle est plac√©e. Diff√©rents objets peuvent √©galement passer par la m√™me interface.

## Critique de la POO

Le mod√®le de programmation orient√© objet a √©t√© critiqu√© par les d√©veloppeurs pour de multiples raisons. La plus grande pr√©occupation est que la POO met trop l'accent sur la composante donn√©es du d√©veloppement logiciel et ne se concentre pas suffisamment sur le calcul ou les algorithmes. De plus, le code POO peut √™tre plus compliqu√© √† √©crire et prendre plus de temps √† compiler.

Les m√©thodes alternatives √† la POO incluent :

- Programmation fonctionnelle. Cela inclut des langages tels que Erlang et Scala, qui sont utilis√©s pour les t√©l√©communications et les syst√®mes tol√©rants aux pannes.
- Programmation structur√©e ou modulaire. Cela inclut des langages tels que PHP et C#.
- Programmation imp√©rative . Cette alternative √† la POO se concentre sur la fonction plut√¥t que sur les mod√®les et inclut C++ et Java.
- Programmation d√©clarative . Cette m√©thode de programmation implique des d√©clarations sur ce qu'est la t√¢che ou le r√©sultat souhait√©, mais pas sur la mani√®re de l'atteindre. Les langages incluent Prolog et Lisp.
- Programmation logique. Cette m√©thode, qui repose principalement sur la logique formelle et utilise des langages tels que Prolog, contient un ensemble de phrases qui expriment des faits ou des r√®gles sur un domaine probl√©matique. Il se concentre sur les t√¢ches qui peuvent b√©n√©ficier de requ√™tes logiques bas√©es sur des r√®gles.

La plupart des langages de programmation avanc√©s permettent aux d√©veloppeurs de combiner des mod√®les, car ils peuvent √™tre utilis√©s pour diff√©rentes m√©thodes de programmation. Par exemple, JavaScript peut √™tre utilis√© pour la POO et la programmation fonctionnelle.

Les d√©veloppeurs qui travaillent avec la POO et les microservices peuvent r√©soudre les probl√®mes courants de microservices en appliquant les principes de la POO .

## Exemple JS
<!--
https://www.freecodecamp.org/news/object-oriented-javascript-for-beginners/
-->
Donc, tout jeu vid√©o a besoin de personnages, n'est-ce pas ? Et tous les personnages ont certaines caract√©ristiques (propri√©t√©s) comme la couleur, la taille, le nom, etc. et des capacit√©s (m√©thodes) comme sauter, courir, frapper, etc. Les objets sont la structure de donn√©es id√©ale √† utiliser pour stocker ce type d'informations.üëå

Disons que nous avons 3 "esp√®ces" de personnages diff√©rentes disponibles, et que nous voulons cr√©er 6 personnages diff√©rents, 2 de chaque esp√®ce.

Une fa√ßon de cr√©er nos personnages pourrait √™tre de simplement cr√©er manuellement les objets en utilisant des litt√©raux d'objet, de cette mani√®re :

``` js
const alien1 = {
    name: "Ali",
    species: "alien",
    phrase: () => console.log("I'm Ali the alien!"),
    fly: () => console.log("Zzzzzziiiiiinnnnnggggg!!")
}
const alien2 = {
    name: "Lien",
    species: "alien",
    sayPhrase: () => console.log("Run for your lives!"),
    fly: () => console.log("Zzzzzziiiiiinnnnnggggg!!")
}
const bug1 = {
    name: "Buggy",
    species: "bug",
    sayPhrase: () => console.log("Your debugger doesn't work with me!"),
    hide: () => console.log("You can't catch me now!")
}
const bug2 = {
    name: "Erik",
    species: "bug",
    sayPhrase: () => console.log("I drink decaf!"),
    hide: () => console.log("You can't catch me now!")
}
const Robot1 = {
    name: "Tito",
    species: "robot",
    sayPhrase: () => console.log("I can cook, swim and dance!"),
    transform: () => console.log("Optimus prime!")
}
const Robot2 = {
    name: "Terminator",
    species: "robot",
    sayPhrase: () => console.log("Hasta la vista, baby!"),
    transform: () => console.log("Optimus prime!")
}
```

V√©rifiez que tous les caract√®res ont les propri√©t√©s de nom et d'esp√®ce, ainsi que la m√©thode sayPhrase. De plus, chaque esp√®ce a une m√©thode qui n'appartient qu'√† cette esp√®ce (par exemple, les extraterrestres ont la m√©thode de la mouche).

Comme vous pouvez le voir, certaines donn√©es sont partag√©es par tous les personnages, certaines donn√©es sont partag√©es par chaque esp√®ce et certaines donn√©es sont uniques √† chaque personnage individuel.

Cette approche fonctionne. Voyez que nous pouvons parfaitement acc√©der √† des propri√©t√©s et des m√©thodes comme celle-ci :

```js
console.log(alien1.name) // output: "Ali"
console.log(bug2.species) // output: "bug"
Robot1.sayPhrase() // output: "I can cook, swim and dance!"
Robot2.transform() // output: "Optimus prime!"
```

Le probl√®me avec cela est qu'il ne s'adapte pas bien du tout et qu'il est sujet aux erreurs. Imaginez que notre jeu puisse avoir des centaines de personnages. Nous aurions besoin de d√©finir manuellement les propri√©t√©s et les m√©thodes pour chacun d'eux !

Pour r√©soudre ce probl√®me, nous avons besoin d'un moyen programmatique de cr√©er des objets et de d√©finir diff√©rentes propri√©t√©s et m√©thodes en fonction d'un ensemble de conditions. Et c'est √† √ßa que servent les cours. üòâ

Les classes d√©finissent un mod√®le pour cr√©er des objets avec des propri√©t√©s et des m√©thodes pr√©d√©finies. En cr√©ant une classe, vous pouvez ult√©rieurement instancier (cr√©er) des objets de cette classe, qui h√©riteront de toutes les propri√©t√©s et m√©thodes de cette classe.

En refactorisant notre code pr√©c√©dent, nous pouvons cr√©er une classe pour chacune de nos esp√®ces de personnages, comme ceci :

```js
class Alien { // Name of the class
    // The constructor method will take a number of parameters and assign those parameters as properties to the created object.
    constructor (name, phrase) {
        this.name = name
        this.phrase = phrase
        this.species = "alien"
    }
    // These will be the object's methods.
    fly = () => console.log("Zzzzzziiiiiinnnnnggggg!!")
    sayPhrase = () => console.log(this.phrase)
}

class Bug {
    constructor (name, phrase) {
        this.name = name
        this.phrase = phrase
        this.species = "bug"
    }
    hide = () => console.log("You can't catch me now!")
    sayPhrase = () => console.log(this.phrase)
}

class Robot {
    constructor (name, phrase) {
        this.name = name
        this.phrase = phrase
        this.species = "robot"
    }
    transform = () => console.log("Optimus prime!")
    sayPhrase = () => console.log(this.phrase)
}
```

Et puis nous pouvons instancier nos personnages √† partir de ces classes comme ceci :

```js
const alien1 = new Alien("Ali", "I'm Ali the alien!")
// We use the "new" keyword followed by the corresponding class name
// and pass it the corresponding parameters according to what was declared in the class constructor function

const alien2 = new Alien("Lien", "Run for your lives!")
const bug1 = new Bug("Buggy", "Your debugger doesn't work with me!")
const bug2 = new Bug("Erik", "I drink decaf!")
const Robot1 = new Robot("Tito", "I can cook, swim and dance!")
const Robot2 = new Robot("Terminator", "Hasta la vista, baby!")
```

Et puis nous pouvons instancier nos personnages √† partir de ces classes comme ceci :Ensuite, nous pouvons acc√©der aux propri√©t√©s et m√©thodes de chaque objet comme ceci :

```js
console.log(alien1.name) // output: "Ali"
console.log(bug2.species) // output: "bug"
Robot1.sayPhrase() // output: "I can cook, swim and dance!"
Robot2.transform() // output: "Optimus prime!"
```

Ce qui est bien avec cette approche et l'utilisation des classes en g√©n√©ral, c'est que nous pouvons utiliser ces "plans" pour cr√©er de nouveaux objets plus rapidement et de mani√®re plus s√©curis√©e que si nous le faisions "manuellement".

De plus, notre code est mieux organis√© car nous pouvons clairement identifier o√π les propri√©t√©s et m√©thodes de chaque objet sont d√©finies (dans la classe). Et cela rend les changements ou adaptations futurs beaucoup plus faciles √† mettre en ≈ìuvre.

## Tour d'horizon

La POO est un paradigme de programmation tr√®s puissant qui peut nous aider √† aborder d'√©normes projets en cr√©ant l'abstraction d'entit√©s. Chaque entit√© sera responsable de certaines informations et actions, et les entit√©s pourront √©galement interagir les unes avec les autres, un peu comme le fonctionnement du monde r√©el.

Dans cet article, nous avons d√©couvert les classes, l'h√©ritage, l'encapsulation, l'abstraction, le polymorphisme et la composition. Ce sont tous des concepts cl√©s dans le monde de la POO. Et nous avons √©galement vu un exemples de la fa√ßon dont la POO peut √™tre impl√©ment√©e en JavaScript.

Bravo et √† la prochaine ! ‚úåÔ∏è

![](https://www.freecodecamp.org/news/content/images/2022/04/98OvjJ.gif)
